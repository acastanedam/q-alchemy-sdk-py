from typing import Tuple

import numpy as np
from qclib.entanglement import geometric_entanglement, meyer_wallach_entanglement
from qclib.util import get_state
from qiskit import QuantumCircuit
from qiskit.circuit.random import random_circuit


def get_vector(e_lower: float, e_upper: float, num_qubits: int,
               start_depth_multiplier=1.0, measure='meyer_wallach'
               ) -> Tuple[np.ndarray, float, float]:
    """
    Create a vector by using random circuits.

    :param e_lower: lower bound of sought for entanglement
    :param e_upper: upper bound of sought for entanglement
    :param num_qubits: number of qubits the state shall have
    :param start_depth_multiplier:
                    (int or list-like)
                    the start depth of the random circuit (default: 1)
                    or the (start, end) depth if a list-like is given
    :param measure:  which measure of entanglement to use,
                    'meyer_wallach' or 'geometric' (default: 'meyer_wallach')
    :return:
        returns a quantum state with entanglement between e_lower and e_upper
        given the entanglement metric, generated by a random circuit
    """
    entanglement = -1.0

    if isinstance(start_depth_multiplier, (int, float)):
        multiplier = start_depth_multiplier
    elif isinstance(start_depth_multiplier, (tuple, list, np.ndarray)):
        assert len(start_depth_multiplier) > 1
        multiplier = np.random.randint(start_depth_multiplier[0], start_depth_multiplier[1])
    else:
        raise ValueError("start_depth_multiplier must be either an int or an array-like of int.")

    iteration = 0
    entanglements = []
    vector = np.ndarray(shape=(0,))
    while e_lower > entanglement or entanglement > e_upper:
        np.random.seed()
        q_circuit: QuantumCircuit = random_circuit(num_qubits, int(np.ceil(multiplier * num_qubits)))
        vector = get_state(q_circuit)
        if measure == 'geometric':
            entanglement = geometric_entanglement(vector)
        elif measure == 'meyer_wallach':
            entanglement = meyer_wallach_entanglement(vector)
        else:
            raise ValueError(f'Entanglement Measure {measure} unknown.')
        iteration += 1
        if iteration > 100:
            multiplier += 1
            iteration = 0
            print(
                f'{multiplier} ({np.min(entanglements):.4f}-{np.max(entanglements):.4f})',
                end='\n', flush=True
            )
            entanglements = []
        else:
            entanglements.append(entanglement)
            print('.', end='', flush=True)
    print(
        f'Final {multiplier} ({np.min(entanglements):.4f}-{np.max(entanglements):.4f})',
        end='\n', flush=True
    )
    return vector, entanglement, multiplier * num_qubits
